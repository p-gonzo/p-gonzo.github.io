{"hash":"bd924ccf606a4b3433bd647d973b1272ce63d6fc","data":{"tag":{"title":"C++","belongsTo":{"edges":[{"node":{"title":"Building Map, Filter, and Reduce in C++ with Templates and Iterators","path":"/blog/posts/building-map-filter-and-reduce-in-c-with-templates-and-iterators/","date":"20. May 2020","timeToRead":8,"description":"For funsies, let's implement JavaScript's <code class=language-text>Map()</code>, <code class=language-text>Filter()</code>, and <code class=language-text>Reduce()</code> in C++.","content":"<p>For starters, let's acknowledge that C++ already has it's own superior versions of Map, Filter, and Reduce in the form of <code class=\"language-text\">std::transform</code>, <code class=\"language-text\">std::remove_if</code>, and <code class=\"language-text\">std::accumulate</code>.  Our goal isn't to compete with these preexisting functions, but to instead learn about several C++ features by implementing simple versions from scratch.  With that out of the way, let's do some functional programming in C++!</p>\n<h2 id=\"part-i---using-a-templated-stdvector\"><a href=\"#part-i---using-a-templated-stdvector\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Part I - Using a templated <code class=\"language-text\">std::vector</code>:</h2>\n<p>Imagining for a moment that we are okay with our <a href=\"https://eloquentjavascript.net/05_higher_order.html#p_cao2fH68Tj\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">higher order functions</a> (map, filter, reduce) only being able to operate on a <code class=\"language-text\">std::vector</code>, we might start with something like this:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> T<span class=\"token operator\">></span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">ForEach</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>items<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> forEachCb<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>T item<span class=\"token operator\">:</span> items<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">forEachCb</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Our ForEach function above accepts an array of type <code class=\"language-text\">T</code> and callback that accepts one item of type <code class=\"language-text\">T</code> as its parameter and returns nothing.  In the ForEach body, we iterate through each item in our vector and invoke the callback on each item.</p>\n<p>We could invoke our ForEach function like so:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> nums <span class=\"token punctuation\">{</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">printNum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> num <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\nForEach<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> printNum<span class=\"token punctuation\">)</span></code></pre>\n<p>Or using Lambda syntax:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> nums <span class=\"token punctuation\">{</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nForEach<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> num <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>For an overview of Lambda Expression syntax, check out the docs from Microsoft <a href=\"https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a>.</p>\n<h3 id=\"map\"><a href=\"#map\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a><code class=\"language-text\">Map()</code>:</h3>\n<p>Because ForEach accepts a callback function, we can use it to compose our three main methods.  Starting with Map, we might implement something like this:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> T<span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> T2<span class=\"token operator\">></span>\nstd<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>T2<span class=\"token operator\">></span> <span class=\"token function\">Map</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>items<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">T2</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> mapCb<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>T2<span class=\"token operator\">></span> mappedVec<span class=\"token punctuation\">;</span>\n    ForEach<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span>mappedVec<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>mapCb<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> mappedVec<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token function\">mapCb</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> mappedVec<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>We can see that Map is a templated function that accepts two types: <code class=\"language-text\">T</code> - the data type contained in the original array, and <code class=\"language-text\">T2</code> - the data type contained in returned array.  The function accepts the parameters <code class=\"language-text\">items</code> a <code class=\"language-text\">std::vector&lt;T&gt;&amp;</code> and a callback function.  The callback accepts a <code class=\"language-text\">T&amp;</code> and returns a <code class=\"language-text\">T2</code>.</p>\n<p>Map creates a <code class=\"language-text\">std::vector&lt;T2&gt;</code> and returns it at the end of the function call.  In between, it invokes ForEach, passing it the original <code class=\"language-text\">std::vector&lt;T&gt;</code> and a callback function that pushes the item onto the <code class=\"language-text\">mappedVec</code> after calling the user-supplied <code class=\"language-text\">mapCb</code> on it.</p>\n<p>It's useful to note that there are two callbacks occurring: <strong>1)</strong> the user-supplied callback which is nested inside <strong>2)</strong> the callback supplied by Map that gets consumed by ForEach.  </p>\n<p>Finally we see the <code class=\"language-text\">[&amp;mappedVec, &amp;mapCb]</code> syntax at the start of our lambda expression.  This allows our <code class=\"language-text\">mappedVec</code> and <code class=\"language-text\">mapCb</code> to remain in scope as the expression <code class=\"language-text\">mappedVec.push_back(mapCb(item))</code> gets passed to ForEach.  This syntax allows us to create a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">closure</a> around those two variables.</p>\n<p>We can then invoke our Map function like so: </p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> nums <span class=\"token punctuation\">{</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">IntContainer</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">IntContainer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token function\">val</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> val <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">auto</span> mappedVed <span class=\"token operator\">=</span> Map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> IntContainer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> <span class=\"token function\">IntContainer</span><span class=\"token punctuation\">(</span>num <span class=\"token operator\">*</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>The example above maps between a <code class=\"language-text\">std::vector</code> containing the <code class=\"language-text\">int</code> type and <code class=\"language-text\">std::vector</code> containing a custom type, <code class=\"language-text\">IntContainer</code>. </p>\n<h3 id=\"filter-and-reduce\"><a href=\"#filter-and-reduce\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a><code class=\"language-text\">Filter()</code> and <code class=\"language-text\">Reduce()</code>:</h3>\n<p>We can implement Filter and Reduce following a similar pattern:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> T<span class=\"token operator\">></span>\nstd<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">Filter</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>items<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> filterCb<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> filteredVec<span class=\"token punctuation\">;</span>\n    ForEach<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span>filteredVec<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>filterCb<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">filterCb</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> filteredVec<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> filteredVec<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Filter doesn't require a second return type <code class=\"language-text\">T2</code>, as we are assuming that the filtered vector will always be of the same type as the input vector.</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> T<span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> T2<span class=\"token operator\">></span>\nT2 <span class=\"token function\">Reduce</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>items<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">T2</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">,</span> T2 <span class=\"token operator\">&amp;</span>memo<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> reduceCb<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T2 <span class=\"token operator\">&amp;</span>start<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    T2 memo <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n    ForEach<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span>memo<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>reduceCb<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> memo <span class=\"token operator\">=</span> <span class=\"token function\">reduceCb</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span> memo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> memo<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Reduce uses a second type, <code class=\"language-text\">T2</code>, however unlike Map, it is not the type contained in a returned <code class=\"language-text\">std::vector</code>, but rather the return type itself.  </p>\n<p>The T2 value is passed as a const ref, <code class=\"language-text\">start</code>, which is assigned to a non-const <code class=\"language-text\">memo</code> variable.  That variable is then mutated each time ForEach runs its callback:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">memo <span class=\"token operator\">=</span> <span class=\"token function\">reduceCb</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span> memo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"part-ii---using-iterators\"><a href=\"#part-ii---using-iterators\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Part II - Using iterators:</h2>\n<p>Though the above code works well, it will only work if our containing class is a <code class=\"language-text\">std::vector</code>.  What if we want to Filter a <code class=\"language-text\">std::string</code> or Reduce a <code class=\"language-text\">std::list</code>?  To do this we'll refactor or original functions above to use the iterator interface.</p>\n<h3 id=\"foreach\"><a href=\"#foreach\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a><code class=\"language-text\">ForEach()</code>:</h3>\n<p>To cut down on the amount of boilerplate, we're going to create a <code class=\"language-text\">using</code> clause that allows us to grab the type contained within an iterator:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> IteratorType<span class=\"token operator\">></span>\n<span class=\"token keyword\">using</span> ItemType <span class=\"token operator\">=</span> <span class=\"token keyword\">typename</span> std<span class=\"token operator\">::</span>iterator_traits<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> IteratorType<span class=\"token operator\">::</span>iterator<span class=\"token operator\">></span><span class=\"token operator\">::</span>value_type<span class=\"token punctuation\">;</span></code></pre>\n<p>With that in place, we can implement our new <code class=\"language-text\">ForEach</code> like so:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> IteratorType<span class=\"token operator\">></span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">ForEach</span><span class=\"token punctuation\">(</span>IteratorType <span class=\"token operator\">&amp;</span>items<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">(</span>ItemType<span class=\"token operator\">&lt;</span>IteratorType<span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> forEachCb<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typename</span> IteratorType<span class=\"token operator\">::</span>iterator ptr <span class=\"token operator\">=</span> items<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> ptr <span class=\"token operator\">!=</span> items<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>ptr<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">forEachCb</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Similar to our original ForEach, the signature requires two parameters, however the first parameter, <code class=\"language-text\">items</code>, is no longer a <code class=\"language-text\">std::vector&lt;T&gt;</code>, but instead an <code class=\"language-text\">IteratorType</code>.  The second parameter is still a <code class=\"language-text\">std::function</code> though it's signature is different in that instead of each item being of type <code class=\"language-text\">T</code>, they're of type <code class=\"language-text\">&lt;ItemType&lt;IteratorType&gt;&gt;</code>.</p>\n<p>Our iteration method has also changed.  Instead of using a C++ <a href=\"https://en.cppreference.com/w/cpp/language/range-for\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">range-based for loop</a>, we're using the <a href=\"https://en.cppreference.com/w/cpp/iterator/iterator\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">iterator interface</a> and a normal for loop to iterate though each item and invoke a callback on the dereferenced pointer.</p>\n<p>The syntax used in the function declaration is messier, however it allows us to do the following:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token operator\">::</span>list<span class=\"token operator\">&lt;</span><span class=\"token keyword\">char</span><span class=\"token operator\">></span> chars <span class=\"token punctuation\">{</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'d'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nstd<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> nums <span class=\"token punctuation\">{</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nstd<span class=\"token operator\">::</span>string word <span class=\"token punctuation\">{</span> <span class=\"token string\">\"Hello\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nForEach<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>list<span class=\"token operator\">&lt;</span><span class=\"token keyword\">char</span><span class=\"token operator\">>></span><span class=\"token punctuation\">(</span>chars<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">&amp;</span>chr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> chr <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nForEach<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> num <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nForEach<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>string<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">&amp;</span>letter<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> letter <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>As you can see, our ForEach function is now agnostic as to whether we are passing a <code class=\"language-text\">std::string</code>, <code class=\"language-text\">std::vector</code>, <code class=\"language-text\">std::list</code>, or any other containing class so long as it implements the iterator interface.</p>\n<h3 id=\"map-filter-and-reduce\"><a href=\"#map-filter-and-reduce\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a><code class=\"language-text\">Map()</code>, <code class=\"language-text\">Filter()</code>, and <code class=\"language-text\">Reduce()</code>:</h3>\n<p>Our new Map function's signature is almost identical to our new ForEach signature, with the only difference being that the callback now returns a <code class=\"language-text\">ItemType&lt;IteratorType&gt;</code> instead of <code class=\"language-text\">void</code>.</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> IteratorType<span class=\"token operator\">></span>\nIteratorType <span class=\"token function\">Map</span><span class=\"token punctuation\">(</span>IteratorType <span class=\"token operator\">&amp;</span>items<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>function<span class=\"token operator\">&lt;</span>ItemType<span class=\"token operator\">&lt;</span>IteratorType<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>ItemType<span class=\"token operator\">&lt;</span>IteratorType<span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> mapCb<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    IteratorType mappedIterator<span class=\"token punctuation\">;</span>\n    ForEach<span class=\"token operator\">&lt;</span>IteratorType<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span>mappedIterator<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>mapCb<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> mappedIterator<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token function\">mapCb</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> mappedIterator<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Filter and Reduce are also updated accordingly:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> IteratorType<span class=\"token operator\">></span>\nIteratorType <span class=\"token function\">Filter</span><span class=\"token punctuation\">(</span>IteratorType <span class=\"token operator\">&amp;</span>items<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">(</span>ItemType<span class=\"token operator\">&lt;</span>IteratorType<span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> filterCb<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    IteratorType filteredIterator<span class=\"token punctuation\">;</span>\n    ForEach<span class=\"token operator\">&lt;</span>IteratorType<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span>filteredIterator<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>filterCb<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">filterCb</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> filteredIterator<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> filteredIterator<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> IteratorType<span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> MemoType<span class=\"token operator\">></span>\nMemoType <span class=\"token function\">Reduce</span><span class=\"token punctuation\">(</span>IteratorType <span class=\"token operator\">&amp;</span>items<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">MemoType</span><span class=\"token punctuation\">(</span>ItemType<span class=\"token operator\">&lt;</span>IteratorType<span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">,</span> MemoType <span class=\"token operator\">&amp;</span>memo<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> reduceCb<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> MemoType <span class=\"token operator\">&amp;</span>start<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    MemoType memo <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n    ForEach<span class=\"token operator\">&lt;</span>IteratorType<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span>memo<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>reduceCb<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> memo <span class=\"token operator\">=</span> <span class=\"token function\">reduceCb</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span> memo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> memo<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>With our three functions rewritten to accommodate any iterator, we can now begin using them.</p>\n<p>Such as using Map to perform a Rot1-like sypher over the characters in a string:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token operator\">::</span>string word <span class=\"token punctuation\">{</span> <span class=\"token string\">\"Hello\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">auto</span> mappedWord <span class=\"token operator\">=</span> Map<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>string<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">&amp;</span>chr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">static_cast</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">char</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>chr <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>Or reducing the a string into the sum of its character integer representations:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token operator\">::</span>string word <span class=\"token punctuation\">{</span> <span class=\"token string\">\"Hello\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> wordToNum <span class=\"token operator\">=</span> Reduce<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>string<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">&amp;</span>chr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>memo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> memo <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>chr<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// The above equals exactly 500 ðŸ¤¯</span></code></pre>\n<p>We can even operate on a <code class=\"language-text\">std::map</code>:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token operator\">::</span>map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">char</span><span class=\"token operator\">></span> items <span class=\"token punctuation\">{</span>std<span class=\"token operator\">::</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nForEach<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">char</span><span class=\"token operator\">>></span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">char</span><span class=\"token operator\">></span> pair<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> pair<span class=\"token punctuation\">.</span>first <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\": \"</span> <span class=\"token operator\">&lt;&lt;</span> pair<span class=\"token punctuation\">.</span>second <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"final-thoughts\"><a href=\"#final-thoughts\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Final Thoughts:</h2>\n<p>Hopefully this was a useful exercise in using iterators and templated functions to recreate the Filter, Map, and Reduce functions that exist on <a href=\"https://developer.mozilla.org/tr/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Array.prototype</a> in JavaScript.  These recreations are presented for academic intrigue, and shouldn't be used in production.</p>\n<p>Our Functions are a little more flexible than the native Javascript versions in that they can work on any containing class that implements the iterator interface.  However, they also lack some of the niceties provided in the native versions or in a library such as <a href=\"https://underscorejs.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Underscore.js</a>.  For example, Underscore's Reduce implementation accounts for the following:</p>\n<blockquote>\n<p>If no memo is passed to the initial invocation of reduce, the iteratee is not invoked on the first element of the list. The first element is instead passed as the memo in the invocation of the iteratee on the next element in the list.</p>\n</blockquote>\n<p>Another area for improvement is ensuring <a href=\"https://isocpp.org/wiki/faq/const-correctness#overview-const\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">const correctness</a> and memory optimization in our function signatures.  Many of our functions and lambda expressions can (and should) be passing by <code class=\"language-text\">const &amp;</code> rather than by value.</p>\n"}},{"node":{"title":"Bit Twiddling in JavaScript","path":"/blog/posts/bit-twiddling-in-java-script/","date":"24. January 2020","timeToRead":5,"description":"Recently, I came across a fun C++ challenge to count the number of set bits in an integer.  Spending a lot of time in the browser, I wanted to re-implement it in JavaScript.","content":"<p>Recently, I came across a fun C++ challenge to <strong>count the number of set bits</strong> in an integer.  Spending a lot of time in the browser, I wanted to re-implement it in JavaScript.</p>\n<p>The challenge itself involves expressing integers in their binary representation.  For those not familiar with base-10 to base-2 conversations, and what <code class=\"language-text\">set bits</code> are, check out the table below:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">number</th>\n<th align=\"center\">128</th>\n<th align=\"center\">64</th>\n<th align=\"center\">32</th>\n<th align=\"center\">16</th>\n<th align=\"center\">8</th>\n<th align=\"center\">4</th>\n<th align=\"center\">2</th>\n<th align=\"center\">0</th>\n<th align=\"center\">conversion</th>\n<th align=\"center\">set bits</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\"><code class=\"language-text\">4</code></td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\"><code class=\"language-text\">1</code></td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">4Â¹ = 4</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">4</code></td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\"><code class=\"language-text\">1</code></td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">4Â¹ = 4</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">8</code></td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\"><code class=\"language-text\">1</code></td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">8Â¹ = 8</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">7</code></td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\"><code class=\"language-text\">1</code></td>\n<td align=\"center\"><code class=\"language-text\">1</code></td>\n<td align=\"center\"><code class=\"language-text\">1</code></td>\n<td align=\"center\">4Â¹+2Â¹+0Â¹ = 7</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">35</code></td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\"><code class=\"language-text\">1</code></td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\"><code class=\"language-text\">1</code></td>\n<td align=\"center\"><code class=\"language-text\">1</code></td>\n<td align=\"center\">32Â¹+2Â¹+0Â¹ = 35</td>\n<td align=\"center\">3</td>\n</tr>\n</tbody>\n</table>\n<br/>\n<h3 id=\"a-note-on-javascript-numbers\"><a href=\"#a-note-on-javascript-numbers\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>A note on JavaScript Numbers:</h3>\n<p>Under the hood, JavaScript represents <em>all</em> numbers as 64 bit floating point numbers.  When we use a bitwise operator on a JavaScript <code class=\"language-text\">number</code>, it is transformed into a 32 bit integer.</p>\n<p>We can demonstrate the conversion to a 32 bit integer by taking a JavaScript <code class=\"language-text\">number</code>, and performing a non mutating right bit shift by zero on it.</p>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\ny <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token comment\">// = 6</span>\n<span class=\"token punctuation\">(</span>y <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">>></span> <span class=\"token number\">0</span> <span class=\"token comment\">// = 6 >> 0 = 6.  Six bit shifted to the right by zero bits is still six</span>\n\n<span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> <span class=\"token number\">2147483647</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// maximum value of a 32 bit integer.</span>\ny <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token comment\">// = 2147483648, number increments correctly.</span>\n<span class=\"token punctuation\">(</span>y <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">>></span> <span class=\"token number\">0</span> <span class=\"token comment\">// = -2147483648, bitwise right shift by zero. 32 bit integer overflows.</span></code></pre>\n<p>MDN, has a very good explanation of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_logical_operators\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">some of the quirks</a> of this conversion:</p>\n<blockquote>\n<p>Numbers with more than 32 bits get their most significant bits discarded. For example, the following integer with more than 32 bits will be converted to a 32 bit integer</p>\n<pre class=\"language-text\"><code class=\"language-text\">Before: 11100110111110100000000000000110000000000001\nAfter:              10100000000000000110000000000001</code></pre>\n</blockquote>\n<p>Don't expect bitwise operations to work as expected with numbers that need more than 32 bits of of memory, or any number over <code class=\"language-text\">2147483647</code>.</p>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// Show two different numbers from binary to base-10:</span>\n\n<span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"11100110111110100000000000000110000000000001\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 15872588537857</span>\n<span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>            <span class=\"token string\">\"10100000000000000110000000000001\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 2684379137</span>\n\n<span class=\"token comment\">// Show those same numbers bit shifted to the right by zero:</span>\n\n<span class=\"token number\">15872588537857</span> <span class=\"token operator\">>></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// -1610588159</span>\n<span class=\"token number\">2684379137</span> <span class=\"token operator\">>></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// -1610588159</span>\n\n<span class=\"token comment\">// Â¯\\_(ãƒ„)_/Â¯</span></code></pre>\n<h3 id=\"displaying-integer-bits-in-javascript\"><a href=\"#displaying-integer-bits-in-javascript\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Displaying integer bits in JavaScript:</h3>\n<p>To see how we can implement <code class=\"language-text\">countSetBits</code>, we will use the following helper function to display the binary representation of an integer:</p>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">displayBits</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">n</span> <span class=\"token arrow operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> bits <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        bits<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">push</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">&amp;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        n <span class=\"token operator\">=</span> n <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> bits<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>Note</strong>: There is a far simpler way of displaying an integer to binary in JavaScript:</p>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"101\"</span>\n<span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// \"111\"</span></code></pre>\n<p>We will instead use the <code class=\"language-text\">displayBits</code> function above to discuss bitwise operators.</p>\n<p>The function stores the ones and zeros in an Array called <code class=\"language-text\">bits</code> and returns it's reversed value.</p>\n<p>In the loop, the function evaluates an integer <code class=\"language-text\">n</code>, and while <code class=\"language-text\">n</code> is not falsey it:</p>\n<ul>\n<li>Evaluates <code class=\"language-text\">n &amp; 1</code>, and pushes the result onto <code class=\"language-text\">bits</code></li>\n<li>Reassigns <code class=\"language-text\">n</code> to <code class=\"language-text\">n &gt;&gt; 1</code></li>\n</ul>\n<h4 id=\"evaluate-n--1-and-push-the-result-onto-bits\"><a href=\"#evaluate-n--1-and-push-the-result-onto-bits\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Evaluate <code class=\"language-text\">n &amp; 1</code>, and push the result onto <code class=\"language-text\">bits</code>:</h4>\n<p>The bitwise <code class=\"language-text\">&amp;</code> operator compares each bit in two integers and returns <code class=\"language-text\">1</code> if both bits are set to <code class=\"language-text\">1</code>, otherwise it returns <code class=\"language-text\">0</code>.</p>\n<p>For example, using 5 and 7:</p>\n<table>\n<thead>\n<tr>\n<th>base 10</th>\n<th align=\"right\">binary</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">5</code></td>\n<td align=\"right\"><code class=\"language-text\">101</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">7</code></td>\n<td align=\"right\"><code class=\"language-text\">111</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">5 &amp; 7</code></td>\n<td align=\"right\"><code class=\"language-text\">101</code></td>\n</tr>\n</tbody>\n</table>\n<br/>\n<p>And using 5 and 1 (our function uses <code class=\"language-text\">n &amp; 1</code>):</p>\n<table>\n<thead>\n<tr>\n<th>base 10</th>\n<th align=\"right\">binary</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">5</code></td>\n<td align=\"right\"><code class=\"language-text\">101</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">1</code></td>\n<td align=\"right\"><code class=\"language-text\">1</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">5 &amp; 1</code></td>\n<td align=\"right\"><code class=\"language-text\">1</code></td>\n</tr>\n</tbody>\n</table>\n<br/>\n<p>Using 7 and 1:</p>\n<table>\n<thead>\n<tr>\n<th>base 10</th>\n<th align=\"right\">binary</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">7</code></td>\n<td align=\"right\"><code class=\"language-text\">111</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">1</code></td>\n<td align=\"right\"><code class=\"language-text\">1</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">7 &amp; 1</code></td>\n<td align=\"right\"><code class=\"language-text\">1</code></td>\n</tr>\n</tbody>\n</table>\n<br/>\n<p>Using 8 and 1:</p>\n<table>\n<thead>\n<tr>\n<th>base 10</th>\n<th align=\"right\">binary</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">8</code></td>\n<td align=\"right\"><code class=\"language-text\">1000</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">1</code></td>\n<td align=\"right\"><code class=\"language-text\">1</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">8 &amp; 1</code></td>\n<td align=\"right\"><code class=\"language-text\">0</code></td>\n</tr>\n</tbody>\n</table>\n<br/>\n<p>We can see that when two ones <strong>in the same position</strong> overlap, the <code class=\"language-text\">&amp;</code> operator returns a <code class=\"language-text\">1</code> in that position, otherwise it returns a <code class=\"language-text\">0</code>.</p>\n<p>When we perform a bitwise <code class=\"language-text\">n &amp; 1</code> we are only are interested in <code class=\"language-text\">n</code>'s <a href=\"https://en.wikipedia.org/wiki/Bit_numbering#Least_significant_bit\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">least significant bit</a> (its rightmost bit), to see if it is a <code class=\"language-text\">0</code> or <code class=\"language-text\">1</code>.</p>\n<p>Because our loop runs <code class=\"language-text\">bits.push(n &amp; 1)</code>, we will either push a <code class=\"language-text\">0</code> or <code class=\"language-text\">1</code> into our bits array based on whether or not <code class=\"language-text\">n</code>'s least significant bit is set or not. </p>\n<h4 id=\"reassign-n-to-n--1\"><a href=\"#reassign-n-to-n--1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Reassign <code class=\"language-text\">n</code> to <code class=\"language-text\">n &gt;&gt; 1</code>:</h4>\n<p>By reassigning <code class=\"language-text\">n</code> to <code class=\"language-text\">n &gt;&gt; 1</code>, we shift all of <code class=\"language-text\">n</code>'s bits to the right by exactly one bit.</p>\n<ul>\n<li>\n<p>The integer 5 in binary is: <code class=\"language-text\">101</code></p>\n<ul>\n<li><code class=\"language-text\">5 &gt;&gt; 1</code> is <code class=\"language-text\">10</code> (<strong>2</strong> as a base-10 integer)</li>\n<li><code class=\"language-text\">5 &gt;&gt; 1 &gt;&gt; 1</code> is <code class=\"language-text\">1</code> (<strong>1</strong> as a base-10 integer)</li>\n<li><code class=\"language-text\">5 &gt;&gt; 1 &gt;&gt; 1 &gt;&gt; 1</code> is <code class=\"language-text\">0</code> (<strong>0</strong> as a base-10 integer)</li>\n</ul>\n</li>\n</ul>\n<p>Putting these two aspects of our loop together allow us to display base 10 integers in their binary format:</p>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">displayBits</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [1, 0, 1]</span>\n<span class=\"token function\">displayBits</span><span class=\"token punctuation\">(</span><span class=\"token number\">9</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [1, 0, 0, 1]</span>\n<span class=\"token function\">displayBits</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [1, 1, 0, 0, 1, 0, 0, 0]</span></code></pre>\n<h3 id=\"counting-set-bits\"><a href=\"#counting-set-bits\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Counting Set Bits:</h3>\n<p>Modifying our <code class=\"language-text\">displayBits</code> function, we can change:</p>\n<ul>\n<li><code class=\"language-text\">const bits = [];</code> to <code class=\"language-text\">let setBits = 0;</code> </li>\n<li><code class=\"language-text\">bits.push(n &amp; 1);</code> to <code class=\"language-text\">setBits += (n &amp; 1);</code></li>\n<li><code class=\"language-text\">return bits.reverse();</code> to <code class=\"language-text\">return setBits;</code></li>\n</ul>\n<p>Making our new function look like this:</p>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">countSetBits</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">n</span> <span class=\"token arrow operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> setBits <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        setBits <span class=\"token operator\">+=</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&amp;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        n <span class=\"token operator\">=</span> n <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> setBits<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>This will certainly work, and when we try it out for ourselves we can see it yields the correct results:</p>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">countSetBits</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 3</span>\n<span class=\"token function\">countSetBits</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1</span></code></pre>\n<p>However, there is a faster (and much more interesting) way to implement this function:</p>\n<h3 id=\"a-more-efficient-way\"><a href=\"#a-more-efficient-way\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>A More Efficient Way:</h3>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">countSetBits</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">n</span> <span class=\"token arrow operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> setBits <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        n <span class=\"token operator\">&amp;=</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        setBits <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> setBits<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>The first thing to notice is that in our while loop we are <strong>always</strong> incrementing setBits by 1. This means that the while loop <em>only</em> iterates <em>m</em> times, where <em>m</em> is the number of set bits.  In our original implementation, our loop always ran <em>n</em> times, where <em>n</em> is the number of bits taken to express the integer.</p>\n<p>Considering the integer <strong>274,877,906,945</strong> which expressed in binary is <code class=\"language-text\">100000000000000000000000000000000000001</code>:</p>\n<p>Our original implementation's while loop would have to run through <strong>39 iterations</strong>, one for each bit.  In our new implementation however, only <strong>2 iterations</strong> are needed.</p>\n<p>Granted, this scenario is somewhat hyperbolic, but it still demonstrates the potential time complexity savings of the second algorithm.</p>\n<p>The \"special sauce\" that gives the second algorithm its advantage lies in the operation, <code class=\"language-text\">n &amp;= n -1;</code>, which reassigns <em>n</em> to the bitwise <code class=\"language-text\">&amp;</code> comparison between itself and n - 1.</p>\n<p>Starting with n = 65, which is <code class=\"language-text\">1000001</code> in binary, we can see how the algorithm terminates in just two iterations:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Iteration</th>\n<th align=\"center\">n</th>\n<th align=\"center\">n - 1</th>\n<th align=\"center\">n &#x26; (n - 1)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\"><code class=\"language-text\">1000001</code></td>\n<td align=\"center\"><code class=\"language-text\">1000000</code></td>\n<td align=\"center\"><code class=\"language-text\">1000000</code></td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\"><code class=\"language-text\">1000000</code></td>\n<td align=\"center\"><code class=\"language-text\">0111111</code></td>\n<td align=\"center\"><code class=\"language-text\">0000000</code></td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\"><code class=\"language-text\">0000000</code></td>\n<td align=\"center\">N/A</td>\n<td align=\"center\">N/A</td>\n</tr>\n</tbody>\n</table>\n<br />\n<p>We can see that by the time the third iteration wants to start, <em>n</em> is already 0, so the iteration never fires and the function exits.</p>\n"}}]}}},"context":{}}