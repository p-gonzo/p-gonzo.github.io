{"hash":"bd924ccf606a4b3433bd647d973b1272ce63d6fc","data":{"tag":{"title":"Functional Programing","belongsTo":{"edges":[{"node":{"title":"Building Map, Filter, and Reduce in C++ with Templates and Iterators","path":"/blog/posts/building-map-filter-and-reduce-in-c-with-templates-and-iterators/","date":"20. May 2020","timeToRead":8,"description":"For funsies, let's implement JavaScript's <code class=language-text>Map()</code>, <code class=language-text>Filter()</code>, and <code class=language-text>Reduce()</code> in C++.","content":"<p>For starters, let's acknowledge that C++ already has it's own superior versions of Map, Filter, and Reduce in the form of <code class=\"language-text\">std::transform</code>, <code class=\"language-text\">std::remove_if</code>, and <code class=\"language-text\">std::accumulate</code>.  Our goal isn't to compete with these preexisting functions, but to instead learn about several C++ features by implementing simple versions from scratch.  With that out of the way, let's do some functional programming in C++!</p>\n<h2 id=\"part-i---using-a-templated-stdvector\"><a href=\"#part-i---using-a-templated-stdvector\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Part I - Using a templated <code class=\"language-text\">std::vector</code>:</h2>\n<p>Imagining for a moment that we are okay with our <a href=\"https://eloquentjavascript.net/05_higher_order.html#p_cao2fH68Tj\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">higher order functions</a> (map, filter, reduce) only being able to operate on a <code class=\"language-text\">std::vector</code>, we might start with something like this:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> T<span class=\"token operator\">></span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">ForEach</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>items<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> forEachCb<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>T item<span class=\"token operator\">:</span> items<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">forEachCb</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Our ForEach function above accepts an array of type <code class=\"language-text\">T</code> and callback that accepts one item of type <code class=\"language-text\">T</code> as its parameter and returns nothing.  In the ForEach body, we iterate through each item in our vector and invoke the callback on each item.</p>\n<p>We could invoke our ForEach function like so:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> nums <span class=\"token punctuation\">{</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">printNum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> num <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\nForEach<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> printNum<span class=\"token punctuation\">)</span></code></pre>\n<p>Or using Lambda syntax:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> nums <span class=\"token punctuation\">{</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nForEach<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> num <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>For an overview of Lambda Expression syntax, check out the docs from Microsoft <a href=\"https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a>.</p>\n<h3 id=\"map\"><a href=\"#map\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a><code class=\"language-text\">Map()</code>:</h3>\n<p>Because ForEach accepts a callback function, we can use it to compose our three main methods.  Starting with Map, we might implement something like this:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> T<span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> T2<span class=\"token operator\">></span>\nstd<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>T2<span class=\"token operator\">></span> <span class=\"token function\">Map</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>items<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">T2</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> mapCb<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>T2<span class=\"token operator\">></span> mappedVec<span class=\"token punctuation\">;</span>\n    ForEach<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span>mappedVec<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>mapCb<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> mappedVec<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token function\">mapCb</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> mappedVec<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>We can see that Map is a templated function that accepts two types: <code class=\"language-text\">T</code> - the data type contained in the original array, and <code class=\"language-text\">T2</code> - the data type contained in returned array.  The function accepts the parameters <code class=\"language-text\">items</code> a <code class=\"language-text\">std::vector&lt;T&gt;&amp;</code> and a callback function.  The callback accepts a <code class=\"language-text\">T&amp;</code> and returns a <code class=\"language-text\">T2</code>.</p>\n<p>Map creates a <code class=\"language-text\">std::vector&lt;T2&gt;</code> and returns it at the end of the function call.  In between, it invokes ForEach, passing it the original <code class=\"language-text\">std::vector&lt;T&gt;</code> and a callback function that pushes the item onto the <code class=\"language-text\">mappedVec</code> after calling the user-supplied <code class=\"language-text\">mapCb</code> on it.</p>\n<p>It's useful to note that there are two callbacks occurring: <strong>1)</strong> the user-supplied callback which is nested inside <strong>2)</strong> the callback supplied by Map that gets consumed by ForEach.  </p>\n<p>Finally we see the <code class=\"language-text\">[&amp;mappedVec, &amp;mapCb]</code> syntax at the start of our lambda expression.  This allows our <code class=\"language-text\">mappedVec</code> and <code class=\"language-text\">mapCb</code> to remain in scope as the expression <code class=\"language-text\">mappedVec.push_back(mapCb(item))</code> gets passed to ForEach.  This syntax allows us to create a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">closure</a> around those two variables.</p>\n<p>We can then invoke our Map function like so: </p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> nums <span class=\"token punctuation\">{</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">IntContainer</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">IntContainer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token function\">val</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> val <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">auto</span> mappedVed <span class=\"token operator\">=</span> Map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> IntContainer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> <span class=\"token function\">IntContainer</span><span class=\"token punctuation\">(</span>num <span class=\"token operator\">*</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>The example above maps between a <code class=\"language-text\">std::vector</code> containing the <code class=\"language-text\">int</code> type and <code class=\"language-text\">std::vector</code> containing a custom type, <code class=\"language-text\">IntContainer</code>. </p>\n<h3 id=\"filter-and-reduce\"><a href=\"#filter-and-reduce\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a><code class=\"language-text\">Filter()</code> and <code class=\"language-text\">Reduce()</code>:</h3>\n<p>We can implement Filter and Reduce following a similar pattern:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> T<span class=\"token operator\">></span>\nstd<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">Filter</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>items<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> filterCb<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> filteredVec<span class=\"token punctuation\">;</span>\n    ForEach<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span>filteredVec<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>filterCb<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">filterCb</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> filteredVec<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> filteredVec<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Filter doesn't require a second return type <code class=\"language-text\">T2</code>, as we are assuming that the filtered vector will always be of the same type as the input vector.</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> T<span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> T2<span class=\"token operator\">></span>\nT2 <span class=\"token function\">Reduce</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>items<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">T2</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">,</span> T2 <span class=\"token operator\">&amp;</span>memo<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> reduceCb<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T2 <span class=\"token operator\">&amp;</span>start<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    T2 memo <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n    ForEach<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span>memo<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>reduceCb<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> memo <span class=\"token operator\">=</span> <span class=\"token function\">reduceCb</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span> memo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> memo<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Reduce uses a second type, <code class=\"language-text\">T2</code>, however unlike Map, it is not the type contained in a returned <code class=\"language-text\">std::vector</code>, but rather the return type itself.  </p>\n<p>The T2 value is passed as a const ref, <code class=\"language-text\">start</code>, which is assigned to a non-const <code class=\"language-text\">memo</code> variable.  That variable is then mutated each time ForEach runs its callback:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">memo <span class=\"token operator\">=</span> <span class=\"token function\">reduceCb</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span> memo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"part-ii---using-iterators\"><a href=\"#part-ii---using-iterators\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Part II - Using iterators:</h2>\n<p>Though the above code works well, it will only work if our containing class is a <code class=\"language-text\">std::vector</code>.  What if we want to Filter a <code class=\"language-text\">std::string</code> or Reduce a <code class=\"language-text\">std::list</code>?  To do this we'll refactor or original functions above to use the iterator interface.</p>\n<h3 id=\"foreach\"><a href=\"#foreach\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a><code class=\"language-text\">ForEach()</code>:</h3>\n<p>To cut down on the amount of boilerplate, we're going to create a <code class=\"language-text\">using</code> clause that allows us to grab the type contained within an iterator:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> IteratorType<span class=\"token operator\">></span>\n<span class=\"token keyword\">using</span> ItemType <span class=\"token operator\">=</span> <span class=\"token keyword\">typename</span> std<span class=\"token operator\">::</span>iterator_traits<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> IteratorType<span class=\"token operator\">::</span>iterator<span class=\"token operator\">></span><span class=\"token operator\">::</span>value_type<span class=\"token punctuation\">;</span></code></pre>\n<p>With that in place, we can implement our new <code class=\"language-text\">ForEach</code> like so:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> IteratorType<span class=\"token operator\">></span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">ForEach</span><span class=\"token punctuation\">(</span>IteratorType <span class=\"token operator\">&amp;</span>items<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">(</span>ItemType<span class=\"token operator\">&lt;</span>IteratorType<span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> forEachCb<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typename</span> IteratorType<span class=\"token operator\">::</span>iterator ptr <span class=\"token operator\">=</span> items<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> ptr <span class=\"token operator\">!=</span> items<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>ptr<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">forEachCb</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Similar to our original ForEach, the signature requires two parameters, however the first parameter, <code class=\"language-text\">items</code>, is no longer a <code class=\"language-text\">std::vector&lt;T&gt;</code>, but instead an <code class=\"language-text\">IteratorType</code>.  The second parameter is still a <code class=\"language-text\">std::function</code> though it's signature is different in that instead of each item being of type <code class=\"language-text\">T</code>, they're of type <code class=\"language-text\">&lt;ItemType&lt;IteratorType&gt;&gt;</code>.</p>\n<p>Our iteration method has also changed.  Instead of using a C++ <a href=\"https://en.cppreference.com/w/cpp/language/range-for\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">range-based for loop</a>, we're using the <a href=\"https://en.cppreference.com/w/cpp/iterator/iterator\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">iterator interface</a> and a normal for loop to iterate though each item and invoke a callback on the dereferenced pointer.</p>\n<p>The syntax used in the function declaration is messier, however it allows us to do the following:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token operator\">::</span>list<span class=\"token operator\">&lt;</span><span class=\"token keyword\">char</span><span class=\"token operator\">></span> chars <span class=\"token punctuation\">{</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'d'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nstd<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> nums <span class=\"token punctuation\">{</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nstd<span class=\"token operator\">::</span>string word <span class=\"token punctuation\">{</span> <span class=\"token string\">\"Hello\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nForEach<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>list<span class=\"token operator\">&lt;</span><span class=\"token keyword\">char</span><span class=\"token operator\">>></span><span class=\"token punctuation\">(</span>chars<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">&amp;</span>chr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> chr <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nForEach<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> num <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nForEach<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>string<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">&amp;</span>letter<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> letter <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>As you can see, our ForEach function is now agnostic as to whether we are passing a <code class=\"language-text\">std::string</code>, <code class=\"language-text\">std::vector</code>, <code class=\"language-text\">std::list</code>, or any other containing class so long as it implements the iterator interface.</p>\n<h3 id=\"map-filter-and-reduce\"><a href=\"#map-filter-and-reduce\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a><code class=\"language-text\">Map()</code>, <code class=\"language-text\">Filter()</code>, and <code class=\"language-text\">Reduce()</code>:</h3>\n<p>Our new Map function's signature is almost identical to our new ForEach signature, with the only difference being that the callback now returns a <code class=\"language-text\">ItemType&lt;IteratorType&gt;</code> instead of <code class=\"language-text\">void</code>.</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> IteratorType<span class=\"token operator\">></span>\nIteratorType <span class=\"token function\">Map</span><span class=\"token punctuation\">(</span>IteratorType <span class=\"token operator\">&amp;</span>items<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>function<span class=\"token operator\">&lt;</span>ItemType<span class=\"token operator\">&lt;</span>IteratorType<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>ItemType<span class=\"token operator\">&lt;</span>IteratorType<span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> mapCb<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    IteratorType mappedIterator<span class=\"token punctuation\">;</span>\n    ForEach<span class=\"token operator\">&lt;</span>IteratorType<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span>mappedIterator<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>mapCb<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> mappedIterator<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token function\">mapCb</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> mappedIterator<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Filter and Reduce are also updated accordingly:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> IteratorType<span class=\"token operator\">></span>\nIteratorType <span class=\"token function\">Filter</span><span class=\"token punctuation\">(</span>IteratorType <span class=\"token operator\">&amp;</span>items<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">(</span>ItemType<span class=\"token operator\">&lt;</span>IteratorType<span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> filterCb<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    IteratorType filteredIterator<span class=\"token punctuation\">;</span>\n    ForEach<span class=\"token operator\">&lt;</span>IteratorType<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span>filteredIterator<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>filterCb<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">filterCb</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> filteredIterator<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> filteredIterator<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> IteratorType<span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> MemoType<span class=\"token operator\">></span>\nMemoType <span class=\"token function\">Reduce</span><span class=\"token punctuation\">(</span>IteratorType <span class=\"token operator\">&amp;</span>items<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">MemoType</span><span class=\"token punctuation\">(</span>ItemType<span class=\"token operator\">&lt;</span>IteratorType<span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">,</span> MemoType <span class=\"token operator\">&amp;</span>memo<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> reduceCb<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> MemoType <span class=\"token operator\">&amp;</span>start<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    MemoType memo <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n    ForEach<span class=\"token operator\">&lt;</span>IteratorType<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span>memo<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>reduceCb<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> memo <span class=\"token operator\">=</span> <span class=\"token function\">reduceCb</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span> memo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> memo<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>With our three functions rewritten to accommodate any iterator, we can now begin using them.</p>\n<p>Such as using Map to perform a Rot1-like sypher over the characters in a string:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token operator\">::</span>string word <span class=\"token punctuation\">{</span> <span class=\"token string\">\"Hello\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">auto</span> mappedWord <span class=\"token operator\">=</span> Map<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>string<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">&amp;</span>chr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">static_cast</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">char</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>chr <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>Or reducing the a string into the sum of its character integer representations:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token operator\">::</span>string word <span class=\"token punctuation\">{</span> <span class=\"token string\">\"Hello\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> wordToNum <span class=\"token operator\">=</span> Reduce<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>string<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">&amp;</span>chr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>memo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> memo <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>chr<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// The above equals exactly 500 ðŸ¤¯</span></code></pre>\n<p>We can even operate on a <code class=\"language-text\">std::map</code>:</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token operator\">::</span>map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">char</span><span class=\"token operator\">></span> items <span class=\"token punctuation\">{</span>std<span class=\"token operator\">::</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nForEach<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">char</span><span class=\"token operator\">>></span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">char</span><span class=\"token operator\">></span> pair<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> pair<span class=\"token punctuation\">.</span>first <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\": \"</span> <span class=\"token operator\">&lt;&lt;</span> pair<span class=\"token punctuation\">.</span>second <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"final-thoughts\"><a href=\"#final-thoughts\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Final Thoughts:</h2>\n<p>Hopefully this was a useful exercise in using iterators and templated functions to recreate the Filter, Map, and Reduce functions that exist on <a href=\"https://developer.mozilla.org/tr/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Array.prototype</a> in JavaScript.  These recreations are presented for academic intrigue, and shouldn't be used in production.</p>\n<p>Our Functions are a little more flexible than the native Javascript versions in that they can work on any containing class that implements the iterator interface.  However, they also lack some of the niceties provided in the native versions or in a library such as <a href=\"https://underscorejs.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Underscore.js</a>.  For example, Underscore's Reduce implementation accounts for the following:</p>\n<blockquote>\n<p>If no memo is passed to the initial invocation of reduce, the iteratee is not invoked on the first element of the list. The first element is instead passed as the memo in the invocation of the iteratee on the next element in the list.</p>\n</blockquote>\n<p>Another area for improvement is ensuring <a href=\"https://isocpp.org/wiki/faq/const-correctness#overview-const\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">const correctness</a> and memory optimization in our function signatures.  Many of our functions and lambda expressions can (and should) be passing by <code class=\"language-text\">const &amp;</code> rather than by value.</p>\n"}}]}}},"context":{}}